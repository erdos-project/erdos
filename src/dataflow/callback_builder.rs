//! # Callback Builders for Multiple Streams
//!
//! This file was generated by with `scripts/make_callback_builder.sh 8 8`.
//! To change callback builders, please edit `scripts/make_callback_builder.py`
//! and use `scripts/make_callback_builder.sh` to generate a new `callback_builder.rs` file.

use std::borrow::Borrow;
use std::sync::Arc;
use std::{cell::RefCell, rc::Rc};

use crate::{
    dataflow::{
        stream::{InternalStatefulReadStream, StreamId},
        Data, State, StatefulReadStream, Timestamp, WriteStream,
    },
    node::operator_event::OperatorEvent,
};

pub trait MultiStreamEventMaker {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent>;
}

pub struct OneReadOneWrite<S0: State, W0: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data> OneReadOneWrite<S0, W0> {
    pub fn new<R0: Data>(rs0: &StatefulReadStream<R0, S0>, ws0: WriteStream<W0>) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &mut WriteStream<W0>)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadOneWriteStateful<S0, W0, S>>> {
        let result = Rc::new(RefCell::new(OneReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadOneWrite<S0, S1, W0>>> {
        let result = Rc::new(RefCell::new(TwoReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<OneReadTwoWrite<S0, W0, W1>>> {
        let result = Rc::new(RefCell::new(OneReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data> MultiStreamEventMaker for OneReadOneWrite<S0, W0> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(&t, &rs0_state.borrow(), &mut ws0);
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadOneWriteStateful<S0: State, W0: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, S: State> OneReadOneWriteStateful<S0, W0, S> {
    pub fn new<R0: Data>(rs0: &StatefulReadStream<R0, S0>, ws0: WriteStream<W0>, state: S) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, S: State> MultiStreamEventMaker for OneReadOneWriteStateful<S0, W0, S> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadTwoWrite<S0: State, W0: Data, W1: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &mut WriteStream<W0>, &mut WriteStream<W1>)>>,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data> OneReadTwoWrite<S0, W0, W1> {
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadTwoWriteStateful<S0, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(OneReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadTwoWrite<S0, S1, W0, W1>>> {
        let result = Rc::new(RefCell::new(TwoReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<OneReadThreeWrite<S0, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(OneReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data> MultiStreamEventMaker for OneReadTwoWrite<S0, W0, W1> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(&t, &rs0_state.borrow(), &mut ws0, &mut ws1);
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadTwoWriteStateful<S0: State, W0: Data, W1: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &mut WriteStream<W0>, &mut WriteStream<W1>)>>,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, S: State> OneReadTwoWriteStateful<S0, W0, W1, S> {
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, S: State> MultiStreamEventMaker
    for OneReadTwoWriteStateful<S0, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadThreeWrite<S0: State, W0: Data, W1: Data, W2: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data> OneReadThreeWrite<S0, W0, W1, W2> {
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(&Timestamp, &S0, &mut WriteStream<W0>, &mut WriteStream<W1>, &mut WriteStream<W2>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadThreeWriteStateful<S0, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(OneReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadThreeWrite<S0, S1, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(TwoReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<OneReadFourWrite<S0, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(OneReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data> MultiStreamEventMaker
    for OneReadThreeWrite<S0, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(&t, &rs0_state.borrow(), &mut ws0, &mut ws1, &mut ws2);
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadThreeWriteStateful<S0: State, W0: Data, W1: Data, W2: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, S: State>
    OneReadThreeWriteStateful<S0, W0, W1, W2, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, S: State> MultiStreamEventMaker
    for OneReadThreeWriteStateful<S0, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadFourWrite<S0: State, W0: Data, W1: Data, W2: Data, W3: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data> OneReadFourWrite<S0, W0, W1, W2, W3> {
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadFourWriteStateful<S0, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(OneReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadFourWrite<S0, S1, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(TwoReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<OneReadFiveWrite<S0, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(OneReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data> MultiStreamEventMaker
    for OneReadFourWrite<S0, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadFourWriteStateful<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State>
    OneReadFourWriteStateful<S0, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State> MultiStreamEventMaker
    for OneReadFourWriteStateful<S0, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadFiveWrite<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data>
    OneReadFiveWrite<S0, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadFiveWriteStateful<S0, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(OneReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadFiveWrite<S0, S1, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(TwoReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<OneReadSixWrite<S0, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(OneReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data> MultiStreamEventMaker
    for OneReadFiveWrite<S0, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadFiveWriteStateful<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, S: State>
    OneReadFiveWriteStateful<S0, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, S: State> MultiStreamEventMaker
    for OneReadFiveWriteStateful<S0, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadSixWrite<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data>
    OneReadSixWrite<S0, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadSixWriteStateful<S0, W0, W1, W2, W3, W4, W5, S>>> {
        let result = Rc::new(RefCell::new(OneReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadSixWrite<S0, S1, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(TwoReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<OneReadSevenWrite<S0, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(OneReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data> MultiStreamEventMaker
    for OneReadSixWrite<S0, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadSixWriteStateful<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, S: State>
    OneReadSixWriteStateful<S0, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, S: State>
    MultiStreamEventMaker for OneReadSixWriteStateful<S0, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadSevenWrite<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data>
    OneReadSevenWrite<S0, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadSevenWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, S>>> {
        let result = Rc::new(RefCell::new(OneReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadSevenWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(TwoReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<OneReadEightWrite<S0, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(OneReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data>
    MultiStreamEventMaker for OneReadSevenWrite<S0, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadSevenWriteStateful<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data, S: State>
    OneReadSevenWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data, S: State>
    MultiStreamEventMaker for OneReadSevenWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadEightWrite<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data, W7: Data>
    OneReadEightWrite<S0, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<OneReadEightWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, W7, S>>> {
        let result = Rc::new(RefCell::new(OneReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs0_state: Arc::clone(&self.rs0_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R1: Data, S1: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R1, S1>,
    ) -> Rc<RefCell<TwoReadEightWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(TwoReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R1, S1>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<S0: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data, W6: Data, W7: Data>
    MultiStreamEventMaker for OneReadEightWrite<S0, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct OneReadEightWriteStateful<
    S0: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs0_state: Arc<S0>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > OneReadEightWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs0_state: rs0.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker for OneReadEightWriteStateful<S0, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadZeroWrite<S0: State, S1: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State> TwoReadZeroWrite<S0, S1> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1)>(&mut self, callback: F) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadZeroWriteStateful<S0, S1, S>>> {
        let result = Rc::new(RefCell::new(TwoReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),

            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadZeroWrite<S0, S1, S2>>> {
        let result = Rc::new(RefCell::new(ThreeReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<TwoReadOneWrite<S0, S1, W0>>> {
        let result = Rc::new(RefCell::new(TwoReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),

            rs0_watermark: None,
            rs1_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State> MultiStreamEventMaker for TwoReadZeroWrite<S0, S1> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(&t, &rs0_state.borrow(), &rs1_state.borrow());
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadZeroWriteStateful<S0: State, S1: State, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S: State> TwoReadZeroWriteStateful<S0, S1, S> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &mut S, &S0, &S1)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S: State> MultiStreamEventMaker for TwoReadZeroWriteStateful<S0, S1, S> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadOneWrite<S0: State, S1: State, W0: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data> TwoReadOneWrite<S0, S1, W0> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1, &mut WriteStream<W0>)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadOneWriteStateful<S0, S1, W0, S>>> {
        let result = Rc::new(RefCell::new(TwoReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadOneWrite<S0, S1, S2, W0>>> {
        let result = Rc::new(RefCell::new(ThreeReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<TwoReadTwoWrite<S0, S1, W0, W1>>> {
        let result = Rc::new(RefCell::new(TwoReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data> MultiStreamEventMaker for TwoReadOneWrite<S0, S1, W0> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(&t, &rs0_state.borrow(), &rs1_state.borrow(), &mut ws0);
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadOneWriteStateful<S0: State, S1: State, W0: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, W0: Data, S: State> TwoReadOneWriteStateful<S0, S1, W0, S> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, W0: Data, S: State> MultiStreamEventMaker
    for TwoReadOneWriteStateful<S0, S1, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadTwoWrite<S0: State, S1: State, W0: Data, W1: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &mut WriteStream<W0>, &mut WriteStream<W1>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data, W1: Data> TwoReadTwoWrite<S0, S1, W0, W1> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadTwoWriteStateful<S0, S1, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(TwoReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadTwoWrite<S0, S1, S2, W0, W1>>> {
        let result = Rc::new(RefCell::new(ThreeReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<TwoReadThreeWrite<S0, S1, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(TwoReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data> MultiStreamEventMaker
    for TwoReadTwoWrite<S0, S1, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadTwoWriteStateful<S0: State, S1: State, W0: Data, W1: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &mut WriteStream<W0>, &mut WriteStream<W1>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, S: State>
    TwoReadTwoWriteStateful<S0, S1, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, S: State> MultiStreamEventMaker
    for TwoReadTwoWriteStateful<S0, S1, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadThreeWrite<S0: State, S1: State, W0: Data, W1: Data, W2: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data> TwoReadThreeWrite<S0, S1, W0, W1, W2> {
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadThreeWriteStateful<S0, S1, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(TwoReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadThreeWrite<S0, S1, S2, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(ThreeReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<TwoReadFourWrite<S0, S1, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(TwoReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data> MultiStreamEventMaker
    for TwoReadThreeWrite<S0, S1, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadThreeWriteStateful<S0: State, S1: State, W0: Data, W1: Data, W2: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, S: State>
    TwoReadThreeWriteStateful<S0, S1, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, S: State> MultiStreamEventMaker
    for TwoReadThreeWriteStateful<S0, S1, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadFourWrite<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data>
    TwoReadFourWrite<S0, S1, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadFourWriteStateful<S0, S1, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(TwoReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadFourWrite<S0, S1, S2, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(ThreeReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<TwoReadFiveWrite<S0, S1, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(TwoReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data> MultiStreamEventMaker
    for TwoReadFourWrite<S0, S1, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadFourWriteStateful<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State>
    TwoReadFourWriteStateful<S0, S1, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State> MultiStreamEventMaker
    for TwoReadFourWriteStateful<S0, S1, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadFiveWrite<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data>
{
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data>
    TwoReadFiveWrite<S0, S1, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadFiveWriteStateful<S0, S1, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(TwoReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadFiveWrite<S0, S1, S2, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(ThreeReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<TwoReadSixWrite<S0, S1, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(TwoReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data> MultiStreamEventMaker
    for TwoReadFiveWrite<S0, S1, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadFiveWriteStateful<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, S: State>
    TwoReadFiveWriteStateful<S0, S1, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, S: State>
    MultiStreamEventMaker for TwoReadFiveWriteStateful<S0, S1, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadSixWrite<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data>
    TwoReadSixWrite<S0, S1, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadSixWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, S>>> {
        let result = Rc::new(RefCell::new(TwoReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadSixWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(ThreeReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<TwoReadSevenWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(TwoReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data, W5: Data>
    MultiStreamEventMaker for TwoReadSixWrite<S0, S1, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadSixWriteStateful<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > TwoReadSixWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker for TwoReadSixWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadSevenWrite<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > TwoReadSevenWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadSevenWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, S>>> {
        let result = Rc::new(RefCell::new(TwoReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadSevenWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(ThreeReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<TwoReadEightWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(TwoReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker for TwoReadSevenWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadSevenWriteStateful<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > TwoReadSevenWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker for TwoReadSevenWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadEightWrite<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > TwoReadEightWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<TwoReadEightWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7, S>>> {
        let result = Rc::new(RefCell::new(TwoReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R2: Data, S2: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R2, S2>,
    ) -> Rc<RefCell<ThreeReadEightWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(ThreeReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R2, S2>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker for TwoReadEightWrite<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct TwoReadEightWriteStateful<
    S0: State,
    S1: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > TwoReadEightWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for TwoReadEightWriteStateful<S0, S1, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadZeroWrite<S0: State, S1: State, S2: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State> ThreeReadZeroWrite<S0, S1, S2> {
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1, &S2)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadZeroWriteStateful<S0, S1, S2, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadZeroWrite<S0, S1, S2, S3>>> {
        let result = Rc::new(RefCell::new(FourReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<ThreeReadOneWrite<S0, S1, S2, W0>>> {
        let result = Rc::new(RefCell::new(ThreeReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State> MultiStreamEventMaker for ThreeReadZeroWrite<S0, S1, S2> {
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadZeroWriteStateful<S0: State, S1: State, S2: State, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S: State> ThreeReadZeroWriteStateful<S0, S1, S2, S> {
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S: State> MultiStreamEventMaker
    for ThreeReadZeroWriteStateful<S0, S1, S2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadOneWrite<S0: State, S1: State, S2: State, W0: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, W0: Data> ThreeReadOneWrite<S0, S1, S2, W0> {
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadOneWriteStateful<S0, S1, S2, W0, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadOneWrite<S0, S1, S2, S3, W0>>> {
        let result = Rc::new(RefCell::new(FourReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<ThreeReadTwoWrite<S0, S1, S2, W0, W1>>> {
        let result = Rc::new(RefCell::new(ThreeReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, W0: Data> MultiStreamEventMaker
    for ThreeReadOneWrite<S0, S1, S2, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadOneWriteStateful<S0: State, S1: State, S2: State, W0: Data, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, W0: Data, S: State>
    ThreeReadOneWriteStateful<S0, S1, S2, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, S: State> MultiStreamEventMaker
    for ThreeReadOneWriteStateful<S0, S1, S2, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadTwoWrite<S0: State, S1: State, S2: State, W0: Data, W1: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &mut WriteStream<W0>, &mut WriteStream<W1>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data> ThreeReadTwoWrite<S0, S1, S2, W0, W1> {
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadTwoWriteStateful<S0, S1, S2, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadTwoWrite<S0, S1, S2, S3, W0, W1>>> {
        let result = Rc::new(RefCell::new(FourReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<ThreeReadThreeWrite<S0, S1, S2, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(ThreeReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data> MultiStreamEventMaker
    for ThreeReadTwoWrite<S0, S1, S2, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadTwoWriteStateful<S0: State, S1: State, S2: State, W0: Data, W1: Data, S: State>
{
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &mut WriteStream<W0>, &mut WriteStream<W1>)>,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, S: State>
    ThreeReadTwoWriteStateful<S0, S1, S2, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, S: State> MultiStreamEventMaker
    for ThreeReadTwoWriteStateful<S0, S1, S2, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadThreeWrite<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data>
    ThreeReadThreeWrite<S0, S1, S2, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadThreeWriteStateful<S0, S1, S2, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadThreeWrite<S0, S1, S2, S3, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(FourReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<ThreeReadFourWrite<S0, S1, S2, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(ThreeReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data> MultiStreamEventMaker
    for ThreeReadThreeWrite<S0, S1, S2, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, S: State>
    ThreeReadThreeWriteStateful<S0, S1, S2, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, S: State> MultiStreamEventMaker
    for ThreeReadThreeWriteStateful<S0, S1, S2, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data>
    ThreeReadFourWrite<S0, S1, S2, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadFourWriteStateful<S0, S1, S2, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadFourWrite<S0, S1, S2, S3, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(FourReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<ThreeReadFiveWrite<S0, S1, S2, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(ThreeReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data> MultiStreamEventMaker
    for ThreeReadFourWrite<S0, S1, S2, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State>
    ThreeReadFourWriteStateful<S0, S1, S2, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data, S: State>
    MultiStreamEventMaker for ThreeReadFourWriteStateful<S0, S1, S2, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data>
    ThreeReadFiveWrite<S0, S1, S2, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadFiveWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadFiveWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(FourReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<ThreeReadSixWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(ThreeReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, W0: Data, W1: Data, W2: Data, W3: Data, W4: Data>
    MultiStreamEventMaker for ThreeReadFiveWrite<S0, S1, S2, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > ThreeReadFiveWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker for ThreeReadFiveWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > ThreeReadSixWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadSixWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadSixWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(FourReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<ThreeReadSevenWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(ThreeReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker for ThreeReadSixWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > ThreeReadSixWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker for ThreeReadSixWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > ThreeReadSevenWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadSevenWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, S>>> {
        let result = Rc::new(RefCell::new(ThreeReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadSevenWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(FourReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<ThreeReadEightWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(ThreeReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker for ThreeReadSevenWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > ThreeReadSevenWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for ThreeReadSevenWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > ThreeReadEightWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<ThreeReadEightWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7, S>>>
    {
        let result = Rc::new(RefCell::new(ThreeReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R3: Data, S3: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R3, S3>,
    ) -> Rc<RefCell<FourReadEightWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(FourReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R3, S3>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker for ThreeReadEightWrite<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct ThreeReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > ThreeReadEightWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for ThreeReadEightWriteStateful<S0, S1, S2, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadZeroWrite<S0: State, S1: State, S2: State, S3: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State> FourReadZeroWrite<S0, S1, S2, S3> {
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadZeroWriteStateful<S0, S1, S2, S3, S>>> {
        let result = Rc::new(RefCell::new(FourReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadZeroWrite<S0, S1, S2, S3, S4>>> {
        let result = Rc::new(RefCell::new(FiveReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<FourReadOneWrite<S0, S1, S2, S3, W0>>> {
        let result = Rc::new(RefCell::new(FourReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State> MultiStreamEventMaker
    for FourReadZeroWrite<S0, S1, S2, S3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadZeroWriteStateful<S0: State, S1: State, S2: State, S3: State, S: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S: State>
    FourReadZeroWriteStateful<S0, S1, S2, S3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S: State> MultiStreamEventMaker
    for FourReadZeroWriteStateful<S0, S1, S2, S3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadOneWrite<S0: State, S1: State, S2: State, S3: State, W0: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data> FourReadOneWrite<S0, S1, S2, S3, W0> {
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadOneWriteStateful<S0, S1, S2, S3, W0, S>>> {
        let result = Rc::new(RefCell::new(FourReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadOneWrite<S0, S1, S2, S3, S4, W0>>> {
        let result = Rc::new(RefCell::new(FiveReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<FourReadTwoWrite<S0, S1, S2, S3, W0, W1>>> {
        let result = Rc::new(RefCell::new(FourReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data> MultiStreamEventMaker
    for FourReadOneWrite<S0, S1, S2, S3, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadOneWriteStateful<S0: State, S1: State, S2: State, S3: State, W0: Data, S: State>
{
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, S: State>
    FourReadOneWriteStateful<S0, S1, S2, S3, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, S: State> MultiStreamEventMaker
    for FourReadOneWriteStateful<S0, S1, S2, S3, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadTwoWrite<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &mut WriteStream<W0>, &mut WriteStream<W1>)>,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data>
    FourReadTwoWrite<S0, S1, S2, S3, W0, W1>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadTwoWriteStateful<S0, S1, S2, S3, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(FourReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadTwoWrite<S0, S1, S2, S3, S4, W0, W1>>> {
        let result = Rc::new(RefCell::new(FiveReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<FourReadThreeWrite<S0, S1, S2, S3, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(FourReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data> MultiStreamEventMaker
    for FourReadTwoWrite<S0, S1, S2, S3, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadTwoWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, S: State>
    FourReadTwoWriteStateful<S0, S1, S2, S3, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, S: State> MultiStreamEventMaker
    for FourReadTwoWriteStateful<S0, S1, S2, S3, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadThreeWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data>
    FourReadThreeWrite<S0, S1, S2, S3, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadThreeWriteStateful<S0, S1, S2, S3, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(FourReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadThreeWrite<S0, S1, S2, S3, S4, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(FiveReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<FourReadFourWrite<S0, S1, S2, S3, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(FourReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data> MultiStreamEventMaker
    for FourReadThreeWrite<S0, S1, S2, S3, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data, S: State>
    FourReadThreeWriteStateful<S0, S1, S2, S3, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data, S: State>
    MultiStreamEventMaker for FourReadThreeWriteStateful<S0, S1, S2, S3, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data, W3: Data>
    FourReadFourWrite<S0, S1, S2, S3, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadFourWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(FourReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadFourWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(FiveReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<FourReadFiveWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(FourReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, W0: Data, W1: Data, W2: Data, W3: Data>
    MultiStreamEventMaker for FourReadFourWrite<S0, S1, S2, S3, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > FourReadFourWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > MultiStreamEventMaker for FourReadFourWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > FourReadFiveWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadFiveWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(FourReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadFiveWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(FiveReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<FourReadSixWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(FourReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > MultiStreamEventMaker for FourReadFiveWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > FourReadFiveWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker for FourReadFiveWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > FourReadSixWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadSixWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, S>>> {
        let result = Rc::new(RefCell::new(FourReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadSixWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(FiveReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<FourReadSevenWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(FourReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker for FourReadSixWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > FourReadSixWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker
    for FourReadSixWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > FourReadSevenWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadSevenWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, S>>>
    {
        let result = Rc::new(RefCell::new(FourReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadSevenWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(FiveReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<FourReadEightWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(FourReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker for FourReadSevenWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > FourReadSevenWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for FourReadSevenWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > FourReadEightWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FourReadEightWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7, S>>>
    {
        let result = Rc::new(RefCell::new(FourReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R4: Data, S4: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R4, S4>,
    ) -> Rc<RefCell<FiveReadEightWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(FiveReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R4, S4>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker for FourReadEightWrite<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FourReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > FourReadEightWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for FourReadEightWriteStateful<S0, S1, S2, S3, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadZeroWrite<S0: State, S1: State, S2: State, S3: State, S4: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State> FiveReadZeroWrite<S0, S1, S2, S3, S4> {
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadZeroWriteStateful<S0, S1, S2, S3, S4, S>>> {
        let result = Rc::new(RefCell::new(FiveReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadZeroWrite<S0, S1, S2, S3, S4, S5>>> {
        let result = Rc::new(RefCell::new(SixReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<FiveReadOneWrite<S0, S1, S2, S3, S4, W0>>> {
        let result = Rc::new(RefCell::new(FiveReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State> MultiStreamEventMaker
    for FiveReadZeroWrite<S0, S1, S2, S3, S4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadZeroWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S: State>
    FiveReadZeroWriteStateful<S0, S1, S2, S3, S4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S: State> MultiStreamEventMaker
    for FiveReadZeroWriteStateful<S0, S1, S2, S3, S4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadOneWrite<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data>
    FiveReadOneWrite<S0, S1, S2, S3, S4, W0>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadOneWriteStateful<S0, S1, S2, S3, S4, W0, S>>> {
        let result = Rc::new(RefCell::new(FiveReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadOneWrite<S0, S1, S2, S3, S4, S5, W0>>> {
        let result = Rc::new(RefCell::new(SixReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<FiveReadTwoWrite<S0, S1, S2, S3, S4, W0, W1>>> {
        let result = Rc::new(RefCell::new(FiveReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data> MultiStreamEventMaker
    for FiveReadOneWrite<S0, S1, S2, S3, S4, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadOneWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, S: State>
    FiveReadOneWriteStateful<S0, S1, S2, S3, S4, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, S: State>
    MultiStreamEventMaker for FiveReadOneWriteStateful<S0, S1, S2, S3, S4, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadTwoWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>, &mut WriteStream<W1>),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data>
    FiveReadTwoWrite<S0, S1, S2, S3, S4, W0, W1>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadTwoWriteStateful<S0, S1, S2, S3, S4, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(FiveReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadTwoWrite<S0, S1, S2, S3, S4, S5, W0, W1>>> {
        let result = Rc::new(RefCell::new(SixReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<FiveReadThreeWrite<S0, S1, S2, S3, S4, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(FiveReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data>
    MultiStreamEventMaker for FiveReadTwoWrite<S0, S1, S2, S3, S4, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadTwoWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data, S: State>
    FiveReadTwoWriteStateful<S0, S1, S2, S3, S4, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data, S: State>
    MultiStreamEventMaker for FiveReadTwoWriteStateful<S0, S1, S2, S3, S4, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadThreeWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data, W2: Data>
    FiveReadThreeWrite<S0, S1, S2, S3, S4, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadThreeWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(FiveReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadThreeWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(SixReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<FiveReadFourWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(FiveReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, W0: Data, W1: Data, W2: Data>
    MultiStreamEventMaker for FiveReadThreeWrite<S0, S1, S2, S3, S4, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > FiveReadThreeWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > MultiStreamEventMaker for FiveReadThreeWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > FiveReadFourWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadFourWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(FiveReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadFourWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(SixReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<FiveReadFiveWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(FiveReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > MultiStreamEventMaker for FiveReadFourWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > FiveReadFourWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > MultiStreamEventMaker for FiveReadFourWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > FiveReadFiveWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadFiveWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(FiveReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadFiveWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(SixReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<FiveReadSixWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(FiveReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > MultiStreamEventMaker for FiveReadFiveWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > FiveReadFiveWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker
    for FiveReadFiveWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > FiveReadSixWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadSixWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, S>>> {
        let result = Rc::new(RefCell::new(FiveReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadSixWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(SixReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<FiveReadSevenWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(FiveReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker for FiveReadSixWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > FiveReadSixWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker
    for FiveReadSixWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > FiveReadSevenWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<FiveReadSevenWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, S>>>
    {
        let result = Rc::new(RefCell::new(FiveReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadSevenWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(SixReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<FiveReadEightWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7>>> {
        let result = Rc::new(RefCell::new(FiveReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker for FiveReadSevenWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > FiveReadSevenWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for FiveReadSevenWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > FiveReadEightWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<FiveReadEightWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7, S>>,
    > {
        let result = Rc::new(RefCell::new(FiveReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R5: Data, S5: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R5, S5>,
    ) -> Rc<RefCell<SixReadEightWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7>>>
    {
        let result = Rc::new(RefCell::new(SixReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R5, S5>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker
    for FiveReadEightWrite<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct FiveReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > FiveReadEightWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for FiveReadEightWriteStateful<S0, S1, S2, S3, S4, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadZeroWrite<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State>
    SixReadZeroWrite<S0, S1, S2, S3, S4, S5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5)>(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S>>> {
        let result = Rc::new(RefCell::new(SixReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadZeroWrite<S0, S1, S2, S3, S4, S5, S6>>> {
        let result = Rc::new(RefCell::new(SevenReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<SixReadOneWrite<S0, S1, S2, S3, S4, S5, W0>>> {
        let result = Rc::new(RefCell::new(SixReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State> MultiStreamEventMaker
    for SixReadZeroWrite<S0, S1, S2, S3, S4, S5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadZeroWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S: State>
    SixReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S: State>
    MultiStreamEventMaker for SixReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadOneWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data>
    SixReadOneWrite<S0, S1, S2, S3, S4, S5, W0>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadOneWriteStateful<S0, S1, S2, S3, S4, S5, W0, S>>> {
        let result = Rc::new(RefCell::new(SixReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadOneWrite<S0, S1, S2, S3, S4, S5, S6, W0>>> {
        let result = Rc::new(RefCell::new(SevenReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<SixReadTwoWrite<S0, S1, S2, S3, S4, S5, W0, W1>>> {
        let result = Rc::new(RefCell::new(SixReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data>
    MultiStreamEventMaker for SixReadOneWrite<S0, S1, S2, S3, S4, S5, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadOneWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data, S: State>
    SixReadOneWriteStateful<S0, S1, S2, S3, S4, S5, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data, S: State>
    MultiStreamEventMaker for SixReadOneWriteStateful<S0, S1, S2, S3, S4, S5, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadTwoWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data, W1: Data>
    SixReadTwoWrite<S0, S1, S2, S3, S4, S5, W0, W1>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &mut WriteStream<W0>, &mut WriteStream<W1>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(SixReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1>>> {
        let result = Rc::new(RefCell::new(SevenReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<SixReadThreeWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(SixReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, W0: Data, W1: Data>
    MultiStreamEventMaker for SixReadTwoWrite<S0, S1, S2, S3, S4, S5, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadTwoWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        S: State,
    > SixReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        S: State,
    > MultiStreamEventMaker for SixReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadThreeWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > SixReadThreeWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(SixReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(SevenReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<SixReadFourWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(SixReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > MultiStreamEventMaker for SixReadThreeWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > SixReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > MultiStreamEventMaker for SixReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > SixReadFourWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadFourWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, S>>> {
        let result = Rc::new(RefCell::new(SixReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadFourWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(SevenReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<SixReadFiveWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(SixReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > MultiStreamEventMaker for SixReadFourWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > SixReadFourWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > MultiStreamEventMaker
    for SixReadFourWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > SixReadFiveWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, S>>> {
        let result = Rc::new(RefCell::new(SixReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(SevenReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<SixReadSixWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(SixReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > MultiStreamEventMaker for SixReadFiveWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > SixReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker
    for SixReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > SixReadSixWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadSixWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, S>>>
    {
        let result = Rc::new(RefCell::new(SixReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadSixWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(SevenReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<SixReadSevenWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6>>> {
        let result = Rc::new(RefCell::new(SixReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker for SixReadSixWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > SixReadSixWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker
    for SixReadSixWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > SixReadSevenWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SixReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, S>>>
    {
        let result = Rc::new(RefCell::new(SixReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6>>>
    {
        let result = Rc::new(RefCell::new(SevenReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<SixReadEightWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7>>>
    {
        let result = Rc::new(RefCell::new(SixReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker
    for SixReadSevenWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > SixReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for SixReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > SixReadEightWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            SixReadEightWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7, S>,
        >,
    > {
        let result = Rc::new(RefCell::new(SixReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R6: Data, S6: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R6, S6>,
    ) -> Rc<RefCell<SevenReadEightWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7>>>
    {
        let result = Rc::new(RefCell::new(SevenReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R6, S6>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker
    for SixReadEightWrite<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SixReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > SixReadEightWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for SixReadEightWriteStateful<S0, S1, S2, S3, S4, S5, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadZeroWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State>
    SevenReadZeroWrite<S0, S1, S2, S3, S4, S5, S6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S>>> {
        let result = Rc::new(RefCell::new(SevenReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadZeroWrite<S0, S1, S2, S3, S4, S5, S6, S7>>> {
        let result = Rc::new(RefCell::new(EightReadZeroWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<SevenReadOneWrite<S0, S1, S2, S3, S4, S5, S6, W0>>> {
        let result = Rc::new(RefCell::new(SevenReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State>
    MultiStreamEventMaker for SevenReadZeroWrite<S0, S1, S2, S3, S4, S5, S6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadZeroWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, S: State>
    SevenReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, S: State>
    MultiStreamEventMaker for SevenReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadOneWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, W0: Data>
    SevenReadOneWrite<S0, S1, S2, S3, S4, S5, S6, W0>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, S>>> {
        let result = Rc::new(RefCell::new(SevenReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadOneWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0>>> {
        let result = Rc::new(RefCell::new(EightReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<SevenReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1>>> {
        let result = Rc::new(RefCell::new(SevenReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, W0: Data>
    MultiStreamEventMaker for SevenReadOneWrite<S0, S1, S2, S3, S4, S5, S6, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadOneWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &mut WriteStream<W0>)>,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        S: State,
    > SevenReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        S: State,
    > MultiStreamEventMaker for SevenReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadTwoWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
    > SevenReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(SevenReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1>>> {
        let result = Rc::new(RefCell::new(EightReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<SevenReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(SevenReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
    > MultiStreamEventMaker for SevenReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadTwoWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        S: State,
    > SevenReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        S: State,
    > MultiStreamEventMaker for SevenReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadThreeWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > SevenReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, S>>> {
        let result = Rc::new(RefCell::new(SevenReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(EightReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<SevenReadFourWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(SevenReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > MultiStreamEventMaker for SevenReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > SevenReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > SevenReadFourWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, S>>>
    {
        let result = Rc::new(RefCell::new(SevenReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadFourWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(EightReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<SevenReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(SevenReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > MultiStreamEventMaker for SevenReadFourWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > SevenReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > SevenReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, S>>>
    {
        let result = Rc::new(RefCell::new(SevenReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(EightReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<SevenReadSixWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5>>> {
        let result = Rc::new(RefCell::new(SevenReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > MultiStreamEventMaker for SevenReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > SevenReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > SevenReadSixWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<SevenReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, S>>>
    {
        let result = Rc::new(RefCell::new(SevenReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadSixWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5>>>
    {
        let result = Rc::new(RefCell::new(EightReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<SevenReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6>>>
    {
        let result = Rc::new(RefCell::new(SevenReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker
    for SevenReadSixWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > SevenReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > SevenReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            SevenReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, S>,
        >,
    > {
        let result = Rc::new(RefCell::new(SevenReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<RefCell<EightReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6>>>
    {
        let result = Rc::new(RefCell::new(EightReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<RefCell<SevenReadEightWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7>>>
    {
        let result = Rc::new(RefCell::new(SevenReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker
    for SevenReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > SevenReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > SevenReadEightWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            SevenReadEightWriteStateful<
                S0,
                S1,
                S2,
                S3,
                S4,
                S5,
                S6,
                W0,
                W1,
                W2,
                W3,
                W4,
                W5,
                W6,
                W7,
                S,
            >,
        >,
    > {
        let result = Rc::new(RefCell::new(SevenReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_read_stream<R7: Data, S7: 'static + State>(
        &mut self,
        read_stream: &StatefulReadStream<R7, S7>,
    ) -> Rc<
        RefCell<
            EightReadEightWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, W7>,
        >,
    > {
        let result = Rc::new(RefCell::new(EightReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: read_stream.get_id(),
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: read_stream.get_state(),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);

        // Register child with read stream
        let internal_read_stream: Rc<RefCell<InternalStatefulReadStream<R7, S7>>> =
            read_stream.into();
        RefCell::borrow(&internal_read_stream).add_child(Rc::clone(&result));

        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker
    for SevenReadEightWrite<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct SevenReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > SevenReadEightWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for SevenReadEightWriteStateful<S0, S1, S2, S3, S4, S5, S6, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadZeroWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, S7: State>
    EightReadZeroWrite<S0, S1, S2, S3, S4, S5, S6, S7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<EightReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, S>>> {
        let result = Rc::new(RefCell::new(EightReadZeroWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W0: Data>(
        &mut self,
        write_stream: &WriteStream<W0>,
    ) -> Rc<RefCell<EightReadOneWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0>>> {
        let result = Rc::new(RefCell::new(EightReadOneWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws0: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<S0: State, S1: State, S2: State, S3: State, S4: State, S5: State, S6: State, S7: State>
    MultiStreamEventMaker for EightReadZeroWrite<S0, S1, S2, S3, S4, S5, S6, S7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadZeroWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,

    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        S: State,
    > EightReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),

            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        S: State,
    > MultiStreamEventMaker for EightReadZeroWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);

            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadOneWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks:
        Vec<Arc<dyn Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7, &mut WriteStream<W0>)>>,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
    > EightReadOneWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static + Fn(&Timestamp, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<EightReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, S>>> {
        let result = Rc::new(RefCell::new(EightReadOneWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W1: Data>(
        &mut self,
        write_stream: &WriteStream<W1>,
    ) -> Rc<RefCell<EightReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1>>> {
        let result = Rc::new(RefCell::new(EightReadTwoWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws1: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
    > MultiStreamEventMaker for EightReadOneWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadOneWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        S: State,
    > EightReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(&Timestamp, &mut S, &S0, &S1, &S2, &S3, &S4, &S5, &S6, &S7, &mut WriteStream<W0>),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        S: State,
    > MultiStreamEventMaker for EightReadOneWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadTwoWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
    > EightReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<EightReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, S>>> {
        let result = Rc::new(RefCell::new(EightReadTwoWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W2: Data>(
        &mut self,
        write_stream: &WriteStream<W2>,
    ) -> Rc<RefCell<EightReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2>>> {
        let result = Rc::new(RefCell::new(EightReadThreeWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws2: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
    > MultiStreamEventMaker for EightReadTwoWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadTwoWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        S: State,
    > EightReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadTwoWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadThreeWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > EightReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<EightReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, S>>>
    {
        let result = Rc::new(RefCell::new(EightReadThreeWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W3: Data>(
        &mut self,
        write_stream: &WriteStream<W3>,
    ) -> Rc<RefCell<EightReadFourWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3>>> {
        let result = Rc::new(RefCell::new(EightReadFourWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws3: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
    > MultiStreamEventMaker for EightReadThreeWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadThreeWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > EightReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadThreeWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadFourWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > EightReadFourWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<RefCell<EightReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, S>>>
    {
        let result = Rc::new(RefCell::new(EightReadFourWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W4: Data>(
        &mut self,
        write_stream: &WriteStream<W4>,
    ) -> Rc<RefCell<EightReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4>>> {
        let result = Rc::new(RefCell::new(EightReadFiveWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws4: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
    > MultiStreamEventMaker for EightReadFourWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadFourWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > EightReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadFourWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadFiveWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > EightReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<EightReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, S>>,
    > {
        let result = Rc::new(RefCell::new(EightReadFiveWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W5: Data>(
        &mut self,
        write_stream: &WriteStream<W5>,
    ) -> Rc<RefCell<EightReadSixWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5>>>
    {
        let result = Rc::new(RefCell::new(EightReadSixWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws5: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
    > MultiStreamEventMaker
    for EightReadFiveWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadFiveWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > EightReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadFiveWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadSixWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > EightReadSixWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            EightReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, S>,
        >,
    > {
        let result = Rc::new(RefCell::new(EightReadSixWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W6: Data>(
        &mut self,
        write_stream: &WriteStream<W6>,
    ) -> Rc<RefCell<EightReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6>>>
    {
        let result = Rc::new(RefCell::new(EightReadSevenWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws6: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
    > MultiStreamEventMaker
    for EightReadSixWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadSixWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > EightReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadSixWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadSevenWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > EightReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            EightReadSevenWriteStateful<
                S0,
                S1,
                S2,
                S3,
                S4,
                S5,
                S6,
                S7,
                W0,
                W1,
                W2,
                W3,
                W4,
                W5,
                W6,
                S,
            >,
        >,
    > {
        let result = Rc::new(RefCell::new(EightReadSevenWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }

    pub fn add_write_stream<W7: Data>(
        &mut self,
        write_stream: &WriteStream<W7>,
    ) -> Rc<
        RefCell<
            EightReadEightWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, W7>,
        >,
    > {
        let result = Rc::new(RefCell::new(EightReadEightWrite {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            ws7: write_stream.clone(),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
    > MultiStreamEventMaker
    for EightReadSevenWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadSevenWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > EightReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadSevenWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, S>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadEightWrite<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > EightReadEightWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, W7>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }

    pub fn add_state<S: State>(
        &mut self,
        state: S,
    ) -> Rc<
        RefCell<
            EightReadEightWriteStateful<
                S0,
                S1,
                S2,
                S3,
                S4,
                S5,
                S6,
                S7,
                W0,
                W1,
                W2,
                W3,
                W4,
                W5,
                W6,
                W7,
                S,
            >,
        >,
    > {
        let result = Rc::new(RefCell::new(EightReadEightWriteStateful {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: self.rs0_id,
            rs1_id: self.rs1_id,
            rs2_id: self.rs2_id,
            rs3_id: self.rs3_id,
            rs4_id: self.rs4_id,
            rs5_id: self.rs5_id,
            rs6_id: self.rs6_id,
            rs7_id: self.rs7_id,
            rs0_state: Arc::clone(&self.rs0_state),
            rs1_state: Arc::clone(&self.rs1_state),
            rs2_state: Arc::clone(&self.rs2_state),
            rs3_state: Arc::clone(&self.rs3_state),
            rs4_state: Arc::clone(&self.rs4_state),
            rs5_state: Arc::clone(&self.rs5_state),
            rs6_state: Arc::clone(&self.rs6_state),
            rs7_state: Arc::clone(&self.rs7_state),
            ws0: self.ws0.clone(),
            ws1: self.ws1.clone(),
            ws2: self.ws2.clone(),
            ws3: self.ws3.clone(),
            ws4: self.ws4.clone(),
            ws5: self.ws5.clone(),
            ws6: self.ws6.clone(),
            ws7: self.ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }));
        self.children
            .push(Rc::clone(&result) as Rc<RefCell<dyn MultiStreamEventMaker>>);
        result
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
    > MultiStreamEventMaker
    for EightReadEightWrite<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, W7>
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();

            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}

pub struct EightReadEightWriteStateful<
    S0: State,
    S1: State,
    S2: State,
    S3: State,
    S4: State,
    S5: State,
    S6: State,
    S7: State,
    W0: Data,
    W1: Data,
    W2: Data,
    W3: Data,
    W4: Data,
    W5: Data,
    W6: Data,
    W7: Data,
    S: State,
> {
    children: Vec<Rc<RefCell<dyn MultiStreamEventMaker>>>,
    watermark_callbacks: Vec<
        Arc<
            dyn Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
        >,
    >,
    rs0_id: StreamId,
    rs1_id: StreamId,
    rs2_id: StreamId,
    rs3_id: StreamId,
    rs4_id: StreamId,
    rs5_id: StreamId,
    rs6_id: StreamId,
    rs7_id: StreamId,
    rs0_state: Arc<S0>,
    rs1_state: Arc<S1>,
    rs2_state: Arc<S2>,
    rs3_state: Arc<S3>,
    rs4_state: Arc<S4>,
    rs5_state: Arc<S5>,
    rs6_state: Arc<S6>,
    rs7_state: Arc<S7>,
    ws0: WriteStream<W0>,
    ws1: WriteStream<W1>,
    ws2: WriteStream<W2>,
    ws3: WriteStream<W3>,
    ws4: WriteStream<W4>,
    ws5: WriteStream<W5>,
    ws6: WriteStream<W6>,
    ws7: WriteStream<W7>,
    rs0_watermark: Option<Timestamp>,
    rs1_watermark: Option<Timestamp>,
    rs2_watermark: Option<Timestamp>,
    rs3_watermark: Option<Timestamp>,
    rs4_watermark: Option<Timestamp>,
    rs5_watermark: Option<Timestamp>,
    rs6_watermark: Option<Timestamp>,
    rs7_watermark: Option<Timestamp>,
    state: Arc<S>,
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    >
    EightReadEightWriteStateful<S0, S1, S2, S3, S4, S5, S6, S7, W0, W1, W2, W3, W4, W5, W6, W7, S>
{
    pub fn new<R0: Data, R1: Data, R2: Data, R3: Data, R4: Data, R5: Data, R6: Data, R7: Data>(
        rs0: &StatefulReadStream<R0, S0>,
        rs1: &StatefulReadStream<R1, S1>,
        rs2: &StatefulReadStream<R2, S2>,
        rs3: &StatefulReadStream<R3, S3>,
        rs4: &StatefulReadStream<R4, S4>,
        rs5: &StatefulReadStream<R5, S5>,
        rs6: &StatefulReadStream<R6, S6>,
        rs7: &StatefulReadStream<R7, S7>,
        ws0: WriteStream<W0>,
        ws1: WriteStream<W1>,
        ws2: WriteStream<W2>,
        ws3: WriteStream<W3>,
        ws4: WriteStream<W4>,
        ws5: WriteStream<W5>,
        ws6: WriteStream<W6>,
        ws7: WriteStream<W7>,
        state: S,
    ) -> Self {
        Self {
            children: Vec::new(),
            watermark_callbacks: Vec::new(),
            rs0_id: rs0.get_id(),
            rs1_id: rs1.get_id(),
            rs2_id: rs2.get_id(),
            rs3_id: rs3.get_id(),
            rs4_id: rs4.get_id(),
            rs5_id: rs5.get_id(),
            rs6_id: rs6.get_id(),
            rs7_id: rs7.get_id(),
            rs0_state: rs0.get_state(),
            rs1_state: rs1.get_state(),
            rs2_state: rs2.get_state(),
            rs3_state: rs3.get_state(),
            rs4_state: rs4.get_state(),
            rs5_state: rs5.get_state(),
            rs6_state: rs6.get_state(),
            rs7_state: rs7.get_state(),
            ws0: ws0.clone(),
            ws1: ws1.clone(),
            ws2: ws2.clone(),
            ws3: ws3.clone(),
            ws4: ws4.clone(),
            ws5: ws5.clone(),
            ws6: ws6.clone(),
            ws7: ws7.clone(),
            rs0_watermark: None,
            rs1_watermark: None,
            rs2_watermark: None,
            rs3_watermark: None,
            rs4_watermark: None,
            rs5_watermark: None,
            rs6_watermark: None,
            rs7_watermark: None,
            state: Arc::new(state),
        }
    }

    pub fn add_watermark_callback<
        F: 'static
            + Fn(
                &Timestamp,
                &mut S,
                &S0,
                &S1,
                &S2,
                &S3,
                &S4,
                &S5,
                &S6,
                &S7,
                &mut WriteStream<W0>,
                &mut WriteStream<W1>,
                &mut WriteStream<W2>,
                &mut WriteStream<W3>,
                &mut WriteStream<W4>,
                &mut WriteStream<W5>,
                &mut WriteStream<W6>,
                &mut WriteStream<W7>,
            ),
    >(
        &mut self,
        callback: F,
    ) {
        self.watermark_callbacks.push(Arc::new(callback));
    }
}

impl<
        S0: State,
        S1: State,
        S2: State,
        S3: State,
        S4: State,
        S5: State,
        S6: State,
        S7: State,
        W0: Data,
        W1: Data,
        W2: Data,
        W3: Data,
        W4: Data,
        W5: Data,
        W6: Data,
        W7: Data,
        S: State,
    > MultiStreamEventMaker
    for EightReadEightWriteStateful<
        S0,
        S1,
        S2,
        S3,
        S4,
        S5,
        S6,
        S7,
        W0,
        W1,
        W2,
        W3,
        W4,
        W5,
        W6,
        W7,
        S,
    >
{
    fn receive_watermark(&mut self, stream_id: StreamId, t: Timestamp) -> Vec<OperatorEvent> {
        let some_t = Some(t.clone());

        if stream_id == self.rs0_id {
            if some_t > self.rs0_watermark {
                self.rs0_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs1_id {
            if some_t > self.rs1_watermark {
                self.rs1_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs2_id {
            if some_t > self.rs2_watermark {
                self.rs2_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs3_id {
            if some_t > self.rs3_watermark {
                self.rs3_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs4_id {
            if some_t > self.rs4_watermark {
                self.rs4_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs5_id {
            if some_t > self.rs5_watermark {
                self.rs5_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs6_id {
            if some_t > self.rs6_watermark {
                self.rs6_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        } else if stream_id == self.rs7_id {
            if some_t > self.rs7_watermark {
                self.rs7_watermark = Some(t.clone());
            } else {
                // The watermark is outdated
                return Vec::new();
            }
        }

        let child_events: Vec<OperatorEvent> = self
            .children
            .iter()
            .map(|child| child.borrow_mut().receive_watermark(stream_id, t.clone()))
            .flatten()
            .collect();

        let mut events = Vec::new();
        if some_t <= self.rs0_watermark
            && some_t <= self.rs1_watermark
            && some_t <= self.rs2_watermark
            && some_t <= self.rs3_watermark
            && some_t <= self.rs4_watermark
            && some_t <= self.rs5_watermark
            && some_t <= self.rs6_watermark
            && some_t <= self.rs7_watermark
            && !(child_events.is_empty() && self.watermark_callbacks.is_empty())
        {
            let watermark_callbacks = self.watermark_callbacks.clone();
            let mut state = Arc::clone(&self.state);
            let rs0_state = Arc::clone(&self.rs0_state);
            let rs1_state = Arc::clone(&self.rs1_state);
            let rs2_state = Arc::clone(&self.rs2_state);
            let rs3_state = Arc::clone(&self.rs3_state);
            let rs4_state = Arc::clone(&self.rs4_state);
            let rs5_state = Arc::clone(&self.rs5_state);
            let rs6_state = Arc::clone(&self.rs6_state);
            let rs7_state = Arc::clone(&self.rs7_state);
            let mut ws0 = self.ws0.clone();
            let mut ws1 = self.ws1.clone();
            let mut ws2 = self.ws2.clone();
            let mut ws3 = self.ws3.clone();
            let mut ws4 = self.ws4.clone();
            let mut ws5 = self.ws5.clone();
            let mut ws6 = self.ws6.clone();
            let mut ws7 = self.ws7.clone();
            if !watermark_callbacks.is_empty() || !child_events.is_empty() {
                events.push(OperatorEvent::new(t.clone(), true, move || {
                    for callback in watermark_callbacks {
                        (callback)(
                            &t,
                            unsafe { Arc::get_mut_unchecked(&mut state) },
                            &rs0_state.borrow(),
                            &rs1_state.borrow(),
                            &rs2_state.borrow(),
                            &rs3_state.borrow(),
                            &rs4_state.borrow(),
                            &rs5_state.borrow(),
                            &rs6_state.borrow(),
                            &rs7_state.borrow(),
                            &mut ws0,
                            &mut ws1,
                            &mut ws2,
                            &mut ws3,
                            &mut ws4,
                            &mut ws5,
                            &mut ws6,
                            &mut ws7,
                        );
                    }
                    for event in child_events {
                        (event.callback)();
                    }
                }));
            }
        }

        events
    }
}
