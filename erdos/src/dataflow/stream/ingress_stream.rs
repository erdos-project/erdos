use std::{
    sync::{Arc, Mutex},
    thread,
    time::Duration,
};

use serde::Deserialize;

use crate::dataflow::{graph::InternalGraph, Data, Message};

use super::{errors::SendError, InternalStream, Stream, StreamId, WriteStream, WriteStreamT};

/// An [`IngressStream`] enables drivers to inject data into a running ERDOS application.
///
/// Similar to a [`WriteStream`], an [`IngressStream`] exposes a [`send`](IngressStream::send)
/// function to allow drivers to send data to the operators of the constructed graph.
///
/// # Example
/// The below example shows how to use an [`IngressStream`] to send data to a
/// [`FlatMapOperator`](crate::dataflow::operators::FlatMapOperator),
/// and retrieve the processed values through an
/// [`EgressStream`](crate::dataflow::stream::EgressStream).
/// ```no_run
/// # use erdos::dataflow::{
/// #    stream::{IngressStream, EgressStream, Stream},
/// #    operators::FlatMapOperator,
/// #    OperatorConfig, Message, Timestamp,
/// #    Graph,
/// # };
/// # use erdos::*;
/// # use erdos::node::Node;
/// #
/// let args = erdos::new_app("ERDOS").get_matches();
/// let mut node = Node::new(Configuration::from_args(&args));
/// let graph = Graph::new();
///
/// // Create an IngressStream.
/// let mut ingress_stream = graph.add_ingress("MapIngressStream");
///
/// // Create an EgressStream from the ReadStream of the FlatMapOperator.
/// let output_stream = graph.connect_one_in_one_out(
///     || FlatMapOperator::new(|x: &usize| { std::iter::once(2 * x) }),
///     || {},
///     OperatorConfig::new().name("MapOperator"),
///     &ingress_stream,
/// );
/// let mut egress_stream = output_stream.to_egress();
///
/// node.run_async(graph);
///
/// // Send data on the IngressStream.
/// for i in 1..10 {
///     ingress_stream.send(Message::new_message(Timestamp::Time(vec![i as u64]), i)).unwrap();
/// }
///
/// // Retrieve mapped values using an EgressStream.
/// for i in 1..10 {
///     let message = egress_stream.read().unwrap();
///     assert_eq!(*message.data().unwrap(), 2 * i);
/// }
/// ```
pub struct IngressStream<D>
where
    for<'a> D: Data + Deserialize<'a>,
{
    // The unique ID of the stream (automatically generated by the constructor)
    id: StreamId,
    // The name of the stream
    name: String,
    // Use a std mutex because the driver doesn't run on the tokio runtime
    write_stream_option: Arc<Mutex<Option<WriteStream<D>>>>,
    // The corresponding internal graph for the stream
    graph: Arc<Mutex<InternalGraph>>,
}

impl<D> IngressStream<D>
where
    for<'a> D: Data + Deserialize<'a>,
{
    /// Returns a new instance of the [`IngressStream`].
    pub(crate) fn new(name: &str, graph: Arc<Mutex<InternalGraph>>) -> Self {
        tracing::debug!(
            "Initializing an IngressStream with name: {}",
            name.to_string()
        );

        Self {
            id: StreamId::new_deterministic(),
            name: name.to_string(),
            write_stream_option: Arc::new(Mutex::new(None)),
            graph: Arc::clone(&graph),
        }
    }

    pub(crate) fn get_write_stream(&self) -> Arc<Mutex<Option<WriteStream<D>>>> {
        Arc::clone(&self.write_stream_option)
    }

    /// Returns `true` if a top watermark message was received or the [`IngressStream`] failed to
    /// set up.
    pub fn is_closed(&self) -> bool {
        self.write_stream_option
            .lock()
            .unwrap()
            .as_ref()
            .map(WriteStream::is_closed)
            .unwrap_or(true)
    }

    /// Sends data on the stream.
    ///
    /// # Arguments
    /// * `msg` - The message to be sent on the stream.
    pub fn send(&mut self, msg: Message<D>) -> Result<(), SendError> {
        if !self.is_closed() {
            loop {
                {
                    if let Some(write_stream) = self.write_stream_option.lock().unwrap().as_mut() {
                        let res = write_stream.send(msg);
                        return res;
                    }
                }
                thread::sleep(Duration::from_millis(100));
            }
        } else {
            tracing::warn!(
                "Trying to send messages on a closed IngressStream {} (ID: {})",
                self.name,
                self.id(),
            );
            Err(SendError::Closed)
        }
    }
}

impl<D> Stream<D> for IngressStream<D>
where
    for<'a> D: Data + Deserialize<'a>,
{
    fn name(&self) -> String {
        self.name.clone()
    }
    fn id(&self) -> StreamId {
        self.id
    }
}

impl<D: Data> InternalStream<D> for IngressStream<D>
where
    for<'a> D: Data + Deserialize<'a>,
{
    fn internal_graph(&self) -> Arc<Mutex<InternalGraph>> {
        Arc::clone(&self.graph)
    }
}

impl<D> WriteStreamT<D> for IngressStream<D>
where
    for<'a> D: Data + Deserialize<'a>,
{
    /// Blocks until write stream is available
    fn send(&mut self, msg: Message<D>) -> Result<(), SendError> {
        self.send(msg)
    }
}
